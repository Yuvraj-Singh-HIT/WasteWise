/**
 * This Firestore Security Ruleset is designed for the WasteWise platform.
 *
 * Core Philosophy:
 * The security model is a hybrid, enforcing strict user-ownership for personal data
 * while enabling controlled, role-based access for business operations. Data is
 * protected by default, and access is explicitly granted based on a user's role
 * in a transaction (e.g., device owner, delivery partner, buyer).
 *
 * Data Structure:
 * - User-specific data (like device uploads) is hierarchically nested under
 *   `/users/{userId}` to leverage path-based security.
 * - Shared, transactional data (like collection requests and part sales) resides
 *   in top-level collections.
 *
 * Key Security Decisions:
 * - User Data Privacy: A user can only access their own document and subcollections
 *   within `/users/{userId}`. User enumeration via list operations on the root
 *   `/users` collection is disabled.
 * - Public Listings: The `/recycled_parts` collection is publicly readable to allow
 *   all users to browse items for sale, but write access is restricted to the
 *   owning recycling agency.
 * - Transactional Security: Access to documents in collections like `/collection_requests`
 *   and `/part_sales` is limited to the specific participants (e.g., owner, buyer,
 *   delivery partner) identified by UID fields within the document. Listing these
 *   collections is disabled to prevent data leakage.
 * - Default Deny: Any operation not explicitly permitted is denied.
 *
 * Denormalization for Authorization:
 * To ensure fast and secure authorization checks, key identifiers are denormalized
 * onto documents. For example, a `part_sales` document contains the `buyerId` and
 * `deliveryPartnerId` directly, avoiding costly and complex `get()` calls to other
 * documents during rule evaluation.
 *
 * Structural Segregation:
 * User-private data (e.g., a user's uploaded devices in `/users/{userId}/devices`) is
 * stored separately from public data (e.g., `/recycled_parts`), which simplifies
 * rules and makes queries more secure and performant.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Validates that the document being operated on already exists.
     * CRITICAL for preventing writes to non-existent documents in update/delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Validates that an incoming 'id' field matches the document's ID.
     * Enforces relational integrity on creation.
     */
    function newDocIdMatches(docId) {
      return request.resource.data.id == docId;
    }
    
    /**
     * Validates that an existing 'id' field is immutable.
     * Prevents re-assigning the document's primary identifier on update.
     */
    function docIdIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * Validates that an ownership field (like 'userId') matches the path owner.
     * Enforces relational integrity on document creation within a user's path.
     */
    function newOwnerFieldMatches(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Validates that an ownership field is immutable on update.
     * Prevents re-assigning ownership of a subcollection document.
     */
    function ownerFieldIsImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow A user (auth.uid='user_abc') can create their own profile at `/users/user_abc`. (create)
     * @deny A user (auth.uid='user_xyz') cannot read or write to another user's profile at `/users/user_abc`. (get, update)
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId} {
      allow get, update: if isOwner(userId);
      allow list: if false; // Prevent user enumeration
      allow create: if isOwner(userId);
      allow delete: if false; // Users cannot delete their own profiles

      /**
       * @description Stores devices uploaded by a specific user.
       * @path /users/{userId}/devices/{deviceId}
       * @allow A user (auth.uid='user_abc') can create a new device in their own subcollection. (create)
       * @deny An anonymous user cannot list devices, even for a known user path. (list)
       * @principle Enforces strict ownership for all operations within a user's private subcollection.
       */
      match /devices/{deviceId} {
        allow get: if isOwner(userId);
        // Allow any authenticated user to list devices for the delivery dashboard
        allow list: if isSignedIn();
        allow create: if isOwner(userId) && newOwnerFieldMatches(userId);
        allow update: if isOwner(userId) || isOwner(get(/databases/$(database)/documents/collection_requests/$(resource.id)).data.deliveryPartnerId);
        allow delete: if isOwner(userId) && isExistingDoc();
      }
    }

    /**
     * @description Manages requests to collect devices. Access is shared between the device owner and the assigned delivery partner.
     * @path /collection_requests/{collectionRequestId}
     * @allow A user (auth.uid='user_abc') who owns a device can create a collection request for it. (create)
     * @deny A user cannot list all collection requests in the system. (list)
     * @principle Implements shared access by checking multiple ownership fields on the document.
     */
    match /collection_requests/{collectionRequestId} {
      // NOTE: Assumes the original device owner's UID is denormalized as 'userId' onto the request document.
      allow get: if isSignedIn() && (isOwner(resource.data.userId) || isOwner(resource.data.deliveryPartnerId));
      allow list: if false; // Prevent leaking all collection requests
      // Allow creation if the creator is the assigned delivery partner
      allow create: if isSignedIn() && isOwner(request.resource.data.deliveryPartnerId);
      allow update: if isSignedIn() && isExistingDoc() && (isOwner(resource.data.userId) || isOwner(resource.data.deliveryPartnerId));
      allow delete: if isOwner(resource.data.userId) && isExistingDoc(); // Only original owner can delete
    }

    /**
     * @description Manages delivery partner profiles.
     * @path /delivery_partners/{deliveryPartnerId}
     * @allow A delivery partner (auth.uid='partner_abc') can update their own profile. (update)
     * @deny A regular user cannot read a delivery partner's private profile information. (get)
     * @principle Enforces document ownership for sensitive partner data. Assumes partner UID matches document ID.
     */
    match /delivery_partners/{deliveryPartnerId} {
      allow get: if isOwner(deliveryPartnerId);
      allow list: if false; // Prevent partner enumeration
      allow create: if false; // Should be created by an admin process
      allow update: if isOwner(deliveryPartnerId) && isExistingDoc();
      allow delete: if false; // Should be deleted by an admin process
    }

    /**
     * @description Manages recycling agency profiles.
     * @path /recycling_agencies/{recyclingAgencyId}
     * @allow An agency user (auth.uid='agency_abc') can update their own profile. (update)
     * @deny A regular user cannot create a new agency profile. (create)
     * @principle Enforces document ownership for agency data. Assumes agency UID matches document ID.
     */
    match /recycling_agencies/{recyclingAgencyId} {
      allow get: if isOwner(recyclingAgencyId);
      allow list: if false; // Prevent agency enumeration
      allow create: if false; // Should be created by an admin process
      allow update: if isOwner(recyclingAgencyId) && isExistingDoc();
      allow delete: if false; // Should be deleted by an admin process
    }

    /**
     * @description Manages recycled parts available for sale. Publicly readable but writeable only by the owning agency.
     * @path /recycled_parts/{recycledPartId}
     * @allow Any user, signed in or not, can view a recycled part for sale. (get, list)
     * @deny A user who is not associated with the recycling agency cannot update the part's price. (update)
     * @principle Implements a "Public Read, Owner Write" pattern, critical for marketplace-style collections.
     */
    match /recycled_parts/{recycledPartId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && isOwner(request.resource.data.recyclingAgencyId);
      allow update: if isSignedIn() && isOwner(resource.data.recyclingAgencyId) && isExistingDoc() && request.resource.data.recyclingAgencyId == resource.data.recyclingAgencyId;
      allow delete: if isSignedIn() && isOwner(resource.data.recyclingAgencyId) && isExistingDoc();
    }

    /**
     * @description Manages the sale of a recycled part. Access is granted to the buyer and delivery partner.
     * @path /part_sales/{partSaleId}
     * @allow A buyer (auth.uid='user_abc') can create a sales record for their purchase. (create)
     * @deny A random user cannot view the sales record of another user's purchase. (get)
     * @principle Restricts access to transaction participants based on denormalized UIDs.
     */
    match /part_sales/{partSaleId} {
      allow get: if isSignedIn() && (isOwner(resource.data.buyerId) || isOwner(resource.data.deliveryPartnerId));
      allow list: if false; // Prevent leaking all sales data
      allow create: if isOwner(request.resource.data.buyerId);
      allow update: if isOwner(resource.data.buyerId) && isExistingDoc();
      allow delete: if false; // Sales records should be immutable
    }

    /**
     * @description Manages financial transactions for delivery partners. Read-only for the partner.
     * @path /delivery_partner_transactions/{deliveryPartnerTransactionId}
     * @allow A delivery partner (auth.uid='partner_abc') can read their own transaction history. (get, list with query)
     * @deny A delivery partner cannot create or modify their own financial records. (create, update, delete)
     * @principle Secures financial data by making it read-only for the owner, with writes controlled by a trusted backend process (Admin SDK).
     */
    match /delivery_partner_transactions/{deliveryPartnerTransactionId} {
      allow get: if isOwner(resource.data.deliveryPartnerId);
      allow list: if false; // Allow only via queries, which rules will enforce
      allow create: if isSignedIn() && isOwner(request.resource.data.deliveryPartnerId); // Allow partner to create their own transaction
      allow update: if false; // Transactions must be immutable
      allow delete: if false; // Transactions must not be deletable by users
    }
  }
}
